import * as THREE from "three";
import { useMemo } from "react";
import { useFrame } from "@react-three/fiber";

type Props = {
  bass: number; // 0..1
  mid: number;  // 0..1
  high: number; // 0..1
  opacity?: number; // 0..1 (to blend into thumbnail)
  blend?: THREE.Blending; // AdditiveBlending looks great
};

export function PsyTunnel({
  bass,
  mid,
  high,
  opacity = 0.85,
  blend = THREE.AdditiveBlending,
}: Props) {
  const material = useMemo(() => {
    const mat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: blend,
      uniforms: {
        uTime: { value: 0 },
        uBass: { value: 0 },
        uMid: { value: 0 },
        uHigh: { value: 0 },
        uOpacity: { value: opacity },
      },
      vertexShader: /* glsl */ `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: /* glsl */ `
        precision highp float;
        varying vec2 vUv;
        uniform float uTime;
        uniform float uBass;
        uniform float uMid;
        uniform float uHigh;
        uniform float uOpacity;

        // Simple palette function (nice neon cycling)
        vec3 palette(float t) {
          vec3 a = vec3(0.5, 0.5, 0.5);
          vec3 b = vec3(0.5, 0.5, 0.5);
          vec3 c = vec3(1.0, 1.0, 1.0);
          vec3 d = vec3(0.10, 0.20, 0.40);
          return a + b * cos(6.28318 * (c * t + d));
        }

        float stripes(float x, float freq) {
          // crisp stripes
          float s = sin(x * freq);
          return smoothstep(0.0, 0.15, abs(s));
        }

        void main() {
          // centered uv
          vec2 p = vUv * 2.0 - 1.0;
          p.x *= 0.46; // adjust for phone-ish aspect feel
          float r = length(p);
          float a = atan(p.y, p.x);

          // audio reactive params
          float kick = uBass;              // tunnel “pump”
          float shimmer = uHigh;           // chroma/brightness
          float drive = uMid;              // spin

          float t = uTime;

          // spiral/tunnel motion
          float zoom = 1.2 + kick * 1.4;
          float spin = (0.35 + drive * 1.2) * t;
          float spiral = a + spin + (1.8 + kick * 2.2) * log(r + 1e-3);

          // stripe field (this creates that "mesmerize" banding)
          float band = stripes(spiral * 2.0 + t * (0.7 + kick * 1.6), 10.0 + kick * 20.0);

          // add radial “waves” for the bending tunnel look
          float wave = sin((1.0 / (r + 0.12)) * (2.2 + kick * 2.0) - t * (1.2 + drive));
          wave = smoothstep(-0.2, 0.9, wave);

          // combine
          float mask = band * wave;

          // color cycling
          float palT = t * 0.08 + spiral * 0.15 + kick * 0.25;
          vec3 col = palette(palT);

          // contrast / b&w mode vibe when desired:
          float bw = smoothstep(0.55, 0.9, 1.0 - shimmer);
          col = mix(col, vec3(mask), bw);

          // brightness
          col *= (0.6 + shimmer * 1.3);

          // vignette-ish
          float vig = smoothstep(1.2, 0.1, r);
          col *= vig;

          gl_FragColor = vec4(col, mask * uOpacity);
        }
      `,
    });

    return mat;
  }, [blend, opacity]);

  useFrame((_, delta) => {
    material.uniforms.uTime.value += delta;
    material.uniforms.uBass.value = bass;
    material.uniforms.uMid.value = mid;
    material.uniforms.uHigh.value = high;
    material.uniforms.uOpacity.value = opacity;
  });

  // Fullscreen quad (clip-space)
  return (
    <mesh frustumCulled={false} renderOrder={10}>
      <planeGeometry args={[2, 2]} />
      <primitive object={material} attach="material" />
    </mesh>
  );
}
