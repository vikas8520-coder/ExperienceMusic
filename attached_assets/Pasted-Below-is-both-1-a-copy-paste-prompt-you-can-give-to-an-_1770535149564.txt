Below is **both**:

1. a **copy-paste prompt** you can give to an AI coder, and
2. a **working starter implementation** (R3F + GLSL raymarch Mandelbulb preset + beat pulse + navigation hooks).

---

## A) Proper prompt (copy/paste)

```text
Implement a new “3D Fractal (Raymarch)” preset inside my React Three Fiber music visualizer.

Context:
- App uses @react-three/fiber, @react-three/drei, @react-three/postprocessing.
- Audio analysis is Web Audio API. I already have beat detection or can add it.
- I have a preset engine (init/update/dispose + uniforms) and a presets panel.

Goal:
Add a premium 3D raymarched fractal preset (Mandelbulb or Mandelbox) that:
1) Renders full-screen using a ShaderMaterial with a raymarch fragment shader (SDF distance estimator).
2) Supports navigation:
   - Orbit controls (mouse drag, touch)
   - Flythrough (WASD + mouse look) OR simple WASD move + Orbit optional toggle
   - Zoom (scroll/pinch or FOV change)
3) Supports infinite zoom “feel”:
   - Use exponential zoom scaling and adaptive epsilon/steps based on camera distance
   - Keep stability by working in local space (recenter or scale coordinates) to avoid large float errors
4) Beat-reactive:
   - Beat spikes should modulate fractal power / deformation and glow/emissive gain and/or zoom punch.
   - Beat pulse should decay smoothly (no flicker).
5) Performance controls:
   - Resolution scale (0.5–1.0)
   - Max ray steps
   - Fractal iterations
   - Max distance and epsilon (adaptive recommended)
6) Premium look:
   - Smooth shading normals
   - Soft fog or vignette
   - Bloom in postprocessing, intensity driven by beat and zoom depth
   - Smooth parameter easing (no abrupt changes)

Deliverables:
- A new preset file: MandelbulbRaymarchPreset.tsx
- A React component that renders a fullscreen plane with ShaderMaterial
- Beat detection utility (simple spectral flux or bass-energy threshold with cooldown)
- Uniform update in useFrame (time, resolution, camera matrices, beat pulse)
- Drei controls integration (OrbitControls + optional PointerLock/Fly)
- Quality preset toggles and safe defaults
```

---

## B) Starter code (R3F preset: Mandelbulb raymarch + beat pulse + navigation)

This is a **single drop-in component** you can mount as a preset view.
It uses:

* fullscreen plane
* raymarch Mandelbulb distance estimator
* simple lighting + normal estimation
* beat pulse uniform
* OrbitControls
* quality sliders (via props/uniforms)

### `MandelbulbRaymarchView.tsx`

```tsx
import * as THREE from "three";
import React, { useMemo, useRef, useState } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { OrbitControls } from "@react-three/drei";

// --------- Simple beat pulse helper (feed it your beat boolean/strength) ----------
function useBeatPulse(decayPerSecond = 6) {
  const [pulse, setPulse] = useState(0);
  useFrame((_, dt) => {
    // exponential decay
    setPulse((p) => Math.max(0, p - decayPerSecond * dt));
  });
  return {
    pulse,
    trigger: (strength = 1) => setPulse((p) => Math.min(1, Math.max(p, strength))),
  };
}

// --------- GLSL: fullscreen raymarch Mandelbulb ----------
const vert = /* glsl */ `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

const frag = /* glsl */ `
precision highp float;

varying vec2 vUv;

uniform vec2  u_resolution;
uniform float u_time;

// camera
uniform vec3 u_camPos;
uniform mat3 u_camRot;   // camera rotation basis (right, up, forward)

// quality
uniform float u_resolutionScale; // 0.5..1.0
uniform int   u_steps;           // raymarch steps
uniform int   u_iter;            // fractal iterations
uniform float u_maxDist;         // far plane
uniform float u_epsilonBase;     // base epsilon

// fractal
uniform float u_power;           // Mandelbulb power (usually 8)
uniform float u_scale;           // overall scale
uniform vec3  u_offset;          // translate fractal in space

// look
uniform float u_glow;            // emissive gain
uniform float u_fog;             // fog amount
uniform float u_beat;            // 0..1 pulse

// distance estimator for Mandelbulb
float mandelbulbDE(vec3 p, float power, int iterations) {
  vec3 z = p;
  float dr = 1.0;
  float r = 0.0;
  for (int i = 0; i < 256; i++) {
    if (i >= iterations) break;
    r = length(z);
    if (r > 2.0) break;

    // spherical coords
    float theta = acos(clamp(z.z / r, -1.0, 1.0));
    float phi = atan(z.y, z.x);
    dr = pow(r, power - 1.0) * power * dr + 1.0;

    float zr = pow(r, power);
    theta *= power;
    phi *= power;

    z = zr * vec3(
      sin(theta) * cos(phi),
      sin(phi) * sin(theta),
      cos(theta)
    );
    z += p;
  }
  // distance estimate
  return 0.5 * log(r) * r / dr;
}

// scene SDF wrapper
float map(vec3 p) {
  // scale & offset (helps with “zoom feel”)
  p = (p - u_offset) * u_scale;
  // beat morph: subtle “breathing” of space / power
  float pw = u_power + u_beat * 0.6;
  return mandelbulbDE(p, pw, u_iter) / u_scale; // undo scale for correct world distance
}

// normal estimation
vec3 getNormal(vec3 p, float eps) {
  vec2 e = vec2(eps, 0.0);
  float dx = map(p + vec3(e.x, e.y, e.y)) - map(p - vec3(e.x, e.y, e.y));
  float dy = map(p + vec3(e.y, e.x, e.y)) - map(p - vec3(e.y, e.x, e.y));
  float dz = map(p + vec3(e.y, e.y, e.x)) - map(p - vec3(e.y, e.y, e.x));
  return normalize(vec3(dx, dy, dz));
}

// shading
vec3 shade(vec3 p, vec3 rd, float eps) {
  vec3 n = getNormal(p, eps);

  // key light + rim light
  vec3 lightDir = normalize(vec3(0.6, 0.8, 0.35));
  float diff = clamp(dot(n, lightDir), 0.0, 1.0);

  float rim = pow(clamp(1.0 - dot(n, -rd), 0.0, 1.0), 2.0);

  // base color + beat tint
  vec3 base = vec3(0.05, 0.25, 0.55);
  vec3 hot  = vec3(1.0, 0.55, 0.15);
  vec3 col = mix(base, hot, u_beat * 0.7);

  // subtle curvature-ish effect
  col *= (0.35 + 0.9 * diff);
  col += rim * 0.35;

  // emissive glow (premium)
  col += (u_glow + u_beat * 0.8) * vec3(0.25, 0.6, 1.0) * (0.2 + 0.8 * diff);

  return col;
}

void main() {
  // Dynamic resolution scale (keep premium 4K option but allow perf)
  vec2 res = u_resolution * u_resolutionScale;

  // NDC coords -1..1
  vec2 uv = vUv * 2.0 - 1.0;
  uv.x *= res.x / res.y;

  // Ray direction from camera basis
  vec3 rd = normalize(u_camRot * vec3(uv, -1.4)); // -Z forward-ish
  vec3 ro = u_camPos;

  float t = 0.0;
  float d = 0.0;

  // adaptive epsilon: smaller when close (more detail)
  // “infinite zoom feel”: detail increases as you get closer
  float eps = u_epsilonBase * (0.25 + 0.75 * clamp(t / 10.0, 0.0, 1.0));

  vec3 col = vec3(0.0);
  bool hit = false;

  for (int i = 0; i < 512; i++) {
    if (i >= u_steps) break;

    vec3 p = ro + rd * t;
    d = map(p);

    // adaptive epsilon based on distance traveled
    eps = max(1e-5, u_epsilonBase * (0.08 + 0.06 * t));

    if (d < eps) {
      hit = true;
      col = shade(p, rd, eps * 2.0);
      break;
    }

    t += d;
    if (t > u_maxDist) break;
  }

  // Background (premium dark gradient + subtle fog)
  vec3 bgTop = vec3(0.02, 0.02, 0.03);
  vec3 bgBot = vec3(0.00, 0.00, 0.00);
  vec3 bg = mix(bgBot, bgTop, smoothstep(-1.0, 1.0, uv.y));

  if (!hit) {
    col = bg;
  } else {
    // fog based on distance t
    float fogAmt = 1.0 - exp(-u_fog * t);
    col = mix(col, bg, fogAmt);
  }

  // mild filmic curve
  col = col / (1.0 + col);

  gl_FragColor = vec4(col, 1.0);
}
`;

export type MandelbulbRaymarchViewProps = {
  // feed your audio beat here (0..1). If you only have boolean, use 1 on beat else 0.
  beat: number;

  // optional "premium quality" defaults
  quality?: "low" | "med" | "high";
};

export function MandelbulbRaymarchView({ beat, quality = "high" }: MandelbulbRaymarchViewProps) {
  const matRef = useRef<THREE.ShaderMaterial>(null!);
  const { size, camera } = useThree();

  const beatPulse = useBeatPulse(7);
  // trigger pulse when beat rises
  const lastBeatRef = useRef(0);
  useFrame(() => {
    const b = beat ?? 0;
    // rising edge trigger
    if (b > 0.7 && lastBeatRef.current <= 0.7) beatPulse.trigger(1);
    lastBeatRef.current = b;
  });

  const defaults = useMemo(() => {
    if (quality === "low") return { rs: 0.6, steps: 96, iter: 10, maxDist: 30, eps: 0.0025 };
    if (quality === "med") return { rs: 0.8, steps: 140, iter: 12, maxDist: 35, eps: 0.0018 };
    return { rs: 1.0, steps: 220, iter: 14, maxDist: 40, eps: 0.0012 };
  }, [quality]);

  // Camera rotation basis (right, up, forward)
  const camRot = useMemo(() => new THREE.Matrix3(), []);

  useFrame(({ clock }, dt) => {
    const m = matRef.current;
    if (!m) return;

    // update camera basis
    const q = camera.quaternion;
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(q);
    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(q);
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(q);
    camRot.set(
      right.x, up.x, forward.x,
      right.y, up.y, forward.y,
      right.z, up.z, forward.z
    );

    m.uniforms.u_time.value = clock.getElapsedTime();
    m.uniforms.u_resolution.value.set(size.width, size.height);

    m.uniforms.u_camPos.value.copy(camera.position);
    m.uniforms.u_camRot.value.copy(camRot);

    // beat pulse (smooth)
    m.uniforms.u_beat.value = beatPulse.pulse;

    // you can also gently “zoom punch” camera on beat:
    // camera.fov = baseFov + beatPulse.pulse * 6; camera.updateProjectionMatrix();
  });

  const uniforms = useMemo(() => {
    return {
      u_resolution: { value: new THREE.Vector2(1, 1) },
      u_time: { value: 0 },

      u_camPos: { value: new THREE.Vector3(0, 0, 4) },
      u_camRot: { value: new THREE.Matrix3() },

      // quality knobs
      u_resolutionScale: { value: defaults.rs },
      u_steps: { value: defaults.steps },
      u_iter: { value: defaults.iter },
      u_maxDist: { value: defaults.maxDist },
      u_epsilonBase: { value: defaults.eps },

      // fractal
      u_power: { value: 8.0 },
      u_scale: { value: 1.0 },
      u_offset: { value: new THREE.Vector3(0, 0, 0) },

      // look
      u_glow: { value: 0.35 },
      u_fog: { value: 0.06 },
      u_beat: { value: 0.0 },
    };
  }, [defaults]);

  return (
    <>
      {/* Controls: orbit around the fractal. 
          You can add a toggle later to switch to PointerLockControls for fly mode. */}
      <OrbitControls enableDamping dampingFactor={0.08} rotateSpeed={0.6} zoomSpeed={0.8} />

      {/* Fullscreen plane. In R3F, scale it to viewport by using a big plane in front of camera */}
      <mesh position={[0, 0, 0]}>
        <planeGeometry args={[10, 10]} />
        <shaderMaterial
          ref={matRef}
          vertexShader={vert}
          fragmentShader={frag}
          uniforms={uniforms as any}
          depthTest={false}
          depthWrite={false}
        />
      </mesh>
    </>
  );
}
```

### How to mount it as a preset

```tsx
// Somewhere in your visualizer scene:
<MandelbulbRaymarchView beat={audio.beat} quality="high" />
```

---

## “Infinite zoom” feel (what to do next)

The starter shader already adapts epsilon with distance, but for a **true premium infinite zoom feeling** you should add *one more trick*:

### Add a zoom scalar that never grows huge

Instead of moving the camera extremely far or having massive coordinates, keep the camera in a “comfortable” range and do:

* `p = (p - offset) * scale;`
* As you “zoom in”, increase `scale` exponentially and move `offset` toward points of interest.

That way you can zoom forever without float drift.

You can wire this to:

* mouse wheel / pinch
* UI “Zoom Rate”
* beat punch

---

## Want the “flythrough WASD” version too?

If you want, I’ll paste a clean `useFlyControls()` hook (WASD + mouse look) that works alongside this and supports:

* “hold right click to fly”
* “double click canvas toggles fullscreen”
* “single click closes panels”

Just say: **“give me fly controls hook”** and whether you want **PointerLock** or **drag-to-look**.
